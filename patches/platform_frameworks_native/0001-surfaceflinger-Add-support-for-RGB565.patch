From ce901912615fe8bca3da8874977d2890b024f47f Mon Sep 17 00:00:00 2001
From: Ricky Cheung <rcheung844@gmail.com>
Date: Sun, 1 May 2022 16:16:59 +0800
Subject: [PATCH] surfaceflinger: Add support for RGB565

This patch adds support for displays that needs RGB565 and reading
format from HWC, this is needed for panels that use the SPI interface.

Change-Id: I6e81a8bef454204017af1c113ef5538abdb9b5c6
---
 services/surfaceflinger/Android.mk              |  7 +++++++
 .../DisplayHardware/HWComposer_hwc1.cpp         | 17 +++++++++++++++++
 .../RenderEngine/RenderEngine.cpp               |  8 ++++++++
 services/surfaceflinger/SurfaceFlinger.cpp      |  8 ++++++++
 4 files changed, 40 insertions(+)

diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index 18cc946..be91740 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -157,6 +157,13 @@ LOCAL_SHARED_LIBRARIES := \
     libpowermanager \
     libvulkan
 
+ifeq ($(GET_FRAMEBUFFER_FORMAT_FROM_HWC),true)
+	LOCAL_CFLAGS += -DGET_FRAMEBUFFER_FORMAT_FROM_HWC
+endif
+ifeq ($(TARGET_USES_16BPPSURFACE_FOR_OPAQUE),true)
+	LOCAL_CFLAGS += -DUSE_16BPPSURFACE_FOR_OPAQUE
+endif
+
 ifeq ($(TARGET_USES_QCOM_BSP), true)
   ifeq ($(TARGET_SUPPORTS_WEARABLES),true)
     LOCAL_C_INCLUDES += $(BOARD_DISPLAY_HAL)/libgralloc
diff --git a/services/surfaceflinger/DisplayHardware/HWComposer_hwc1.cpp b/services/surfaceflinger/DisplayHardware/HWComposer_hwc1.cpp
index 317f948..62a3d5f 100644
--- a/services/surfaceflinger/DisplayHardware/HWComposer_hwc1.cpp
+++ b/services/surfaceflinger/DisplayHardware/HWComposer_hwc1.cpp
@@ -351,6 +351,9 @@ static const uint32_t DISPLAY_ATTRIBUTES[] = {
     HWC_DISPLAY_HEIGHT,
     HWC_DISPLAY_DPI_X,
     HWC_DISPLAY_DPI_Y,
+#ifdef GET_FRAMEBUFFER_FORMAT_FROM_HWC
+    HWC_DISPLAY_FBFORMAT,
+#endif
     HWC_DISPLAY_COLOR_TRANSFORM,
     HWC_DISPLAY_NO_ATTRIBUTE,
 };
@@ -362,6 +365,9 @@ static const uint32_t PRE_HWC15_DISPLAY_ATTRIBUTES[] = {
     HWC_DISPLAY_HEIGHT,
     HWC_DISPLAY_DPI_X,
     HWC_DISPLAY_DPI_Y,
+#ifdef GET_FRAMEBUFFER_FORMAT_FROM_HWC
+    HWC_DISPLAY_FBFORMAT,
+#endif
     HWC_DISPLAY_NO_ATTRIBUTE,
 };
 
@@ -422,6 +428,11 @@ status_t HWComposer::queryDisplayProperties(int disp) {
                 case HWC_DISPLAY_DPI_Y:
                     config.ydpi = values[i] / 1000.0f;
                     break;
+#ifdef GET_FRAMEBUFFER_FORMAT_FROM_HWC
+                case HWC_DISPLAY_FBFORMAT:
+                    mDisplayData[disp].format = values[i];
+                    break;
+#endif
                 case HWC_DISPLAY_COLOR_TRANSFORM:
                     config.colorMode = static_cast<android_color_mode_t>(values[i]);
                     break;
@@ -442,10 +453,12 @@ status_t HWComposer::queryDisplayProperties(int disp) {
     }
 
     // FIXME: what should we set the format to?
+#ifndef GET_FRAMEBUFFER_FORMAT_FROM_HWC
 #ifdef USE_BGRA_8888
     mDisplayData[disp].format = HAL_PIXEL_FORMAT_BGRA_8888;
 #else
     mDisplayData[disp].format = HAL_PIXEL_FORMAT_RGBA_8888;
+#endif
 #endif
     mDisplayData[disp].connected = true;
     return NO_ERROR;
@@ -508,10 +521,14 @@ sp<Fence> HWComposer::getDisplayFence(int disp) const {
 
 uint32_t HWComposer::getFormat(int disp) const {
     if (static_cast<uint32_t>(disp) >= MAX_HWC_DISPLAYS || !mAllocatedDisplayIDs.hasBit(disp)) {
+#ifdef GET_FRAMEBUFFER_FORMAT_FROM_HWC
+        return mDisplayData[HWC_DISPLAY_PRIMARY].format;
+#else
 #ifdef USE_BGRA_8888
         return HAL_PIXEL_FORMAT_BGRA_8888;
 #else
         return HAL_PIXEL_FORMAT_RGBA_8888;
+#endif
 #endif
     } else {
         return mDisplayData[disp].format;
diff --git a/services/surfaceflinger/RenderEngine/RenderEngine.cpp b/services/surfaceflinger/RenderEngine/RenderEngine.cpp
index 28b3319..1cfb5b5 100644
--- a/services/surfaceflinger/RenderEngine/RenderEngine.cpp
+++ b/services/surfaceflinger/RenderEngine/RenderEngine.cpp
@@ -378,11 +378,19 @@ static status_t selectEGLConfig(EGLDisplay display, EGLint format,
         attribs[EGL_RECORDABLE_ANDROID]         = EGL_TRUE;
         attribs[EGL_SURFACE_TYPE]               = EGL_WINDOW_BIT|EGL_PBUFFER_BIT;
         attribs[EGL_FRAMEBUFFER_TARGET_ANDROID] = EGL_TRUE;
+#ifdef USE_16BPPSURFACE_FOR_OPAQUE
+        attribs[EGL_RED_SIZE]                   = 5;
+        attribs[EGL_GREEN_SIZE]                 = 6;
+        attribs[EGL_BLUE_SIZE]                  = 5;
+        wantedAttribute                         = EGL_NATIVE_VISUAL_ID;
+        wantedAttributeValue                    = format;
+#else
         attribs[EGL_RED_SIZE]                   = 8;
         attribs[EGL_GREEN_SIZE]                 = 8;
         attribs[EGL_BLUE_SIZE]                  = 8;
         wantedAttribute                         = EGL_NONE;
         wantedAttributeValue                    = EGL_NONE;
+#endif
     } else {
         // if no renderable type specified, fallback to a simplified query
         wantedAttribute                         = EGL_NATIVE_VISUAL_ID;
diff --git a/services/surfaceflinger/SurfaceFlinger.cpp b/services/surfaceflinger/SurfaceFlinger.cpp
index d71baf9..0f60e15 100644
--- a/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/services/surfaceflinger/SurfaceFlinger.cpp
@@ -2602,10 +2602,18 @@ status_t SurfaceFlinger::createNormalLayer(const sp<Client>& client,
     switch (format) {
     case PIXEL_FORMAT_TRANSPARENT:
     case PIXEL_FORMAT_TRANSLUCENT:
+#ifdef USE_16BPPSURFACE_FOR_OPAQUE
+        format = PIXEL_FORMAT_RGB_565;
+#else
         format = PIXEL_FORMAT_RGBA_8888;
+#endif
         break;
     case PIXEL_FORMAT_OPAQUE:
+#ifdef USE_16BPPSURFACE_FOR_OPAQUE
+        format = PIXEL_FORMAT_RGB_565;
+#else
         format = PIXEL_FORMAT_RGBX_8888;
+#endif
         break;
     }
 
-- 
2.25.1

